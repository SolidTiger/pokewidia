<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <title>Show HP Stats - Select Pokemon</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    
    <a href="index.html" class="button">Home</a>
    <h1 style="position:relative; left:150px; top:2px">HP in descending order</h1>
    <div id="my_dataviz"></div>
    <button type="button" class="button" onclick="clear_data()" style="position:relative; left:145px; top:-10px">Clear All</button>
    <div id="grid"></div>

</body>
<!--D3.JS & JAVASCRIPT CODE HERE-->
<!--I have no idea how to structure this in a good way right now-->
<script>
     //TODO: Implement color-coding function of pokemon types?

    const getPokemonData = async (term) => {
        const response = await fetch(`https://pokeapi.co/api/v2/pokemon/${term}`);
        const data = await response.json();
        return data;
    }

    var pokemon_data = [];
    var promises = [];
    var shown_data = [];
    //Grid used for displaying the choosable pokémon
    var gridData = new Array();
    

    //Temporary solution to get pokemon data
    //Fetches all starter pokemon from gen 1, including their evolutions
    //This could probably be done in a better way, not using a for loop
    for(let i = 1; i < 152; i++) {
        promises.push(getPokemonData(i))
    }

    //Solution to wait for all fethces to be done
    Promise.all(promises).then((data) => {
        data.forEach((pokemon) => {
            pokemon_data.push({
                group: pokemon.name.charAt(0).toUpperCase() + pokemon.name.slice(1),
                value: pokemon.stats[0].base_stat,
                img: pokemon.sprites.other.dream_world.front_default
            });
        })
        initgrid(16, 10, pokemon_data, 151) 
        update(shown_data)
    })
    
    /**
     * Initialization of the graph
     **/
    // set the dimensions and margins of the graph
    var margin = {top: 30, right: 30, bottom: 70, left: 60},
    width = 660 - margin.left - margin.right,
    height = 600 - margin.top - margin.bottom;
    
    // append the svg object to the body of the page
    var svg = d3.select("#my_dataviz")
    .append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
        .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");

    // Initialize the X axis
    var x = d3.scaleBand()
    .range([ 0, width ])
    .padding(0.2);
    var xAxis = svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    
    
    // Initialize the Y axis
    var y = d3.scaleLinear()
    .range([ height, 0]);
    var yAxis = svg.append("g")
    .attr("class", "myYaxis")

    //X-axis label
    // svg.append("text")
    // .attr("text-anchor", "end")
    // .attr("x", width-260)
    // .attr("y", height + margin.top + 20)
    // .text("Pokémon");

    //Y-axis label 
    svg.append("text")
    .attr("text-anchor", "end")
    .attr("transform", "rotate(-90)")
    .attr("y", -margin.left+20)
    .attr("x", -margin.top-170)
    .text("Hitpoints (HP)")
    
    //Tooltip for hovering over bars
    const tooltip = d3.select("#my_dataviz")
    .append("div")
    .style("opacity", 0)
    .attr("class", "tooltip")
    .style("background-color", "white")
    .style("border", "solid")
    .style("border-width", "1px")
    .style("border-radius", "5px")
    .style("padding", "10px")
    .style("position", "absolute")
    .style("z-index", 5)
    
    //Function for initializing the grid
    function initgrid(num_rows, num_cols, pokemon_data, limit) {
        //var grid = new Array();
        var xpos = 1; 
        var ypos = 1; 
        var width = 50; 
        var height = 50; 
        
        for(let row = 0; row < num_rows; row++) {
            gridData.push(new Array());
            
            for(var column = 0; column < num_cols; column++) {
                if(row*num_cols + column >= limit) {
                    break;
                }
                gridData[row].push({
                    x: xpos,
                    y: ypos,
                    width: width,
                    height: height,
                    pokemon: pokemon_data[row*num_cols + column]
                })
                xpos += width;
            }
            xpos = 1;
            ypos += height; 
        }

        var grid = d3.select("#grid")
        .append("svg")
        .attr("width","510px")
        .attr("height","810px");
        
        var row = grid.selectAll(".row")
        .data(gridData)
        .enter().append("g")
        .attr("class", "row");

        
        var column = row.selectAll(".square")
        .data(function(d) { return d; })
        .enter().append("rect")
        .attr("class","square")
        .attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; })
        .attr("width", function(d) { return d.width; })
        .attr("height", function(d) { return d.height; })
        .attr("pokemon", function(d) {return d.pokemon })
        .style("fill", "white")
        .style("stroke", "black")
        
        
        var images = row.selectAll(".image")
        .data(function(d) { return d; })
        .enter().append("svg:image")
        .attr("class","image")
        .attr("x", function(d) { return d.x; })
        .attr("y", function(d) { return d.y; })
        .attr("width", "50px")
        .attr("height", "50px")
        .attr("selected", "false")
        .attr("xlink:href", function(d) { return d.pokemon.img; })
        .on("click", function(event, d) { 
                //Click event for selecting a pokemon
                var column = d3.selectAll(".square")
                .filter(function(square) { return square.x === d.x && square.y == d.y; });
                
                //Transitions not working atm for some reason
                column
                .style("fill", function() { 
                    return d3.select(this).style("fill") === "white" ? "#ce2312" : "white"; 
                })
                //These should be added before
                .transition()
                .duration(10)

                
                if(d3.select(this).attr("selected") === "false") {
                    d3.select(this).attr("selected", "true")
                    shown_data.push(d.pokemon)
                }
                else {
                    d3.select(this).attr("selected", "false")
                    shown_data = shown_data.filter(function(pokemon) { return pokemon.group !== d.pokemon.group; })
                }
                update(shown_data)
        })
        .on("mouseover", function(event, d) { 
                tooltip
                    .html(d.pokemon.group)
                    .style("opacity", 1)
                d3.select(this).transition()
                .duration('50')
                .attr('opacity', '.75')
            })
        .on("mousemove", function(event, d) {
            tooltip.style("transform","translateY(-55%)")
            .style("left", (event.pageX) + "px")
            .style("top", (event.pageY) - 30 + "px")
        })
        .on('mouseout', function (event, d) {
            tooltip
                .style("opacity", 0)
            d3.select(this).transition()
            .duration('50')
            .attr('opacity', '1');
        })
        

        //Initialize the graph with the first 3 pokemon and reflect it in the filling of the grid
        shown_data = pokemon_data.slice(0, 3)
        shown_data.forEach(function(pokemon) {
            var column = d3.selectAll(".square")
            .filter(function(square) { return square.pokemon.group === pokemon.group; });
            column
            .style("fill", "#ce2312")
            
            var image = d3.selectAll(".image")
            .filter(function(square) { return square.pokemon.group === pokemon.group; });
            image
            .attr("selected", "true")
        })   
    }
</script>
<script>
    // Clear all data from the plot
    function clear_data() {
        shown_data.forEach(function(pokemon) {
            var column = d3.selectAll(".square")
            .filter(function(square) { return square.pokemon.group === pokemon.group; });
            column
            .style("fill", function() { 
                    return d3.select(this).style("fill") === "white" ? "#ce2312" : "white"; 
            })
            
            var image = d3.selectAll(".image")
            .filter(function(square) { return square.pokemon.group === pokemon.group; });
            image
            .attr("selected", "false")
        })
        shown_data = []
        update(shown_data)   
    }

    // Updates the plot
    function update(data) {
        
        //Sort descending
        data.sort(function(b, a) {
            return a.value - b.value;
        });

        // Update the X axis
        x.domain(data.map(function(d) { return d.group; }))
        xAxis.call(d3.axisBottom(x))
            .selectAll("text")
            .attr("transform", "translate(-10,0)rotate(-45)")
            .style("text-anchor", "end")
            .attr("font-size", "15");

        // Update the Y axis
        y.domain([0, d3.max(data, function(d) { return d.value }) ]);
        yAxis.transition().duration(1000).call(d3.axisLeft(y));

        // Create the u variable
        var u = svg.selectAll("rect")
            .data(data)

            u
            .enter()
            .append("rect") // Add a new rect for each new elements
            .merge(u) // get the already existing elements as well
            .attr("x", function(d) { return x(d.group); })
            .attr("y", function(d) { return y(d.value); })
            .attr("width", x.bandwidth())
            .attr("height", function(d) { return height - y(d.value); })
            .attr("fill", "#e95e39")
            .on("mouseover", function(event, d) { 
                const name = d.group
                const hp = d.value
                tooltip
                    .html(d.group + "<br>" + "hp: " + hp)
                    .style("opacity", 1)
                d3.select(this).transition()
                .duration('50')
                .attr('opacity', '.75')
            })
            .on("mousemove", function(event, d) {
                tooltip.style("transform","translateY(-55%)")
                .style("left", (event.pageX) + "px")
                .style("top", (event.pageY) - 30 + "px")
            })
            .on('mouseout', function (event, d) {
                tooltip
                    .style("opacity", 0)
                d3.select(this).transition()
               .duration('50')
               .attr('opacity', '1');
            })
            

        // If less group in the new dataset, I delete the ones not in use anymore
        u
            .exit()
            .remove()
    }
</script>
</html>
